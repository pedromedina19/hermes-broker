package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.61 DO NOT EDIT.

import (
	"context"
	"fmt"

	"github.com/pedromedina19/hermes-broker/graph/model"
)

func (r *mutationResolver) Publish(ctx context.Context, topic string, payload string) (*model.PublishResponse, error) {
	err := r.Service.Publish(ctx, topic, []byte(payload))
	if err != nil {
		return &model.PublishResponse{Success: false}, fmt.Errorf("failed to publish: %w", err)
	}
	return &model.PublishResponse{Success: true}, nil
}

func (r *queryResolver) Health(ctx context.Context) (string, error) {
	return "Hermes GraphQL is Alive", nil
}

func (r *subscriptionResolver) Subscribe(ctx context.Context, topic string, groupID *string) (<-chan *model.Message, error) {
	gID := ""
	if groupID != nil {
		gID = *groupID
	}

	domainChan, subID, err := r.Service.Subscribe(ctx, topic, gID)
	if err != nil {
		return nil, err
	}

	gqlChan := make(chan *model.Message)

	go func() {
		defer r.Service.RemoveSubscriber(topic, subID)
		defer close(gqlChan)

		for {
			select {
			case <-ctx.Done():
				return
			case msg, ok := <-domainChan:
				if !ok {
					return
				}
				gqlChan <- &model.Message{
					ID:        msg.ID,
					Topic:     msg.Topic,
					Payload:   string(msg.Payload),
					Timestamp: int32(msg.Timestamp.Unix()), 
				}

				r.Service.Acknowledge(subID, msg.ID)
			}
		}
	}()

	return gqlChan, nil
}

func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }
func (r *Resolver) Query() QueryResolver       { return &queryResolver{r} }
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }