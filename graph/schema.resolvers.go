package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.85

import (
	"context"
	"fmt"

	"github.com/pedromedina19/hermes-broker/graph/model"
	"github.com/pedromedina19/hermes-broker/pb"
)

// Publish is the resolver for the publish field.
func (r *mutationResolver) Publish(ctx context.Context, topic string, payload string, mode *model.DeliveryMode) (*model.PublishResponse, error) {
	pbMode := pb.DeliveryMode_CONSISTENT
	if mode != nil {
		switch *mode {
		case model.DeliveryModeEventual:
			pbMode = pb.DeliveryMode_EVENTUAL
		case model.DeliveryModePerformance:
			pbMode = pb.DeliveryMode_PERFORMANCE
		}
	}
	err := r.Service.Publish(ctx, topic, []byte(payload), pbMode)
	if err != nil {
		return &model.PublishResponse{Success: false}, fmt.Errorf("failed to publish: %w", err)
	}
	return &model.PublishResponse{Success: true}, nil
}

func (r *mutationResolver) PublishBatch(ctx context.Context, topic string, payloads []string, mode *model.DeliveryMode) (*model.PublishResponse, error) {
	pbMode := pb.DeliveryMode_CONSISTENT
	if mode != nil {
		switch *mode {
		case model.DeliveryModeEventual:
			pbMode = pb.DeliveryMode_EVENTUAL
		case model.DeliveryModePerformance:
			pbMode = pb.DeliveryMode_PERFORMANCE
		}
	}

	data := make([][]byte, len(payloads))
	for i, p := range payloads {
		data[i] = []byte(p)
	}

	err := r.Service.PublishBatchList(ctx, topic, data, pbMode)
	if err != nil {
		return &model.PublishResponse{Success: false}, fmt.Errorf("failed to publish batch: %w", err)
	}
	return &model.PublishResponse{Success: true}, nil
}

// Health is the resolver for the health field.
func (r *queryResolver) Health(ctx context.Context) (string, error) {
	return "Hermes GraphQL is Alive", nil
}

// Subscribe is the resolver for the subscribe field.
func (r *subscriptionResolver) Subscribe(ctx context.Context, topic string, groupID *string) (<-chan *model.Message, error) {
	gID := ""
	if groupID != nil {
		gID = *groupID
	}

	domainChan, subID, err := r.Service.Subscribe(ctx, topic, gID)
	if err != nil {
		return nil, err
	}

	gqlChan := make(chan *model.Message)

	go func() {
		defer r.Service.RemoveSubscriber(topic, subID)
		defer close(gqlChan)

		for {
			select {
			case <-ctx.Done():
				return
			case msg, ok := <-domainChan:
				if !ok {
					return
				}
				gqlChan <- &model.Message{
					ID:        msg.ID,
					Topic:     msg.Topic,
					Payload:   string(msg.Payload),
					Timestamp: int32(msg.Timestamp.Unix()),
				}

				r.Service.Acknowledge(subID, msg.ID)
			}
		}
	}()

	return gqlChan, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
